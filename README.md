# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:

- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:

- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```

## Описание проекта

Проект "Веб-ларек" реализует пример типового сервиса для покупки товаров. Пользователь может просматривать каталог товаров, при клике на товар отрывать модальное окно с его полным описанием, также при помощи открывшегося модального окна добавлять товар в корзину, при оформлении заказа пользователь может выбрать способ оплаты. Проект реализован на TypeScript и представляет собой SPA (Single Page Application) с использованием API для получения данных о товарах.

Особенности реализации:
— до оформления заказа содержимое корзины сохраняется в localStorage;
— после успешного заказа контактные данные сохраняются в localStorage и подставляются в форму заказа в следующий раз.

<!-- ## Описание интерфейса

Интерфейс можно условно разделить на 2 процесса:

1. Просмотр каталога товаров (MainScreen)
2. Оформление заказа (BasketScreen, OrderScreen, SuccessScreen)

Так как модальные окна в проекте однотипные, то их общая логика и структура вынесена в абстрактный класс ModalScreen. Все модальные окна наследуются от него и переопределяют методы для своих нужд. -->

## Данные и типы данных используемые в проекте

Продукт

```typescript
export interface IProduct {
	id:string,
    description: string,
    image: string,
    title: string,
    category: string,
    price: number|null
}
```
Пользователь

```typescript
export interface IUser {
	payment: string;
	address: string;
    email: string;
	phone: string;
}
```

Заказ. Данный интерфейс расширяет интерфейс пользователя

```typescript
export interface IOrder extends IUser {
	items: Pick<IProduct, 'id'>[]; //список id товаров
	total:number; // стоимость заказа
}
```

API для получения продуктов и отправки заказа

```typescript
export interface IShopAPI {
	getProducts: () => Promise<IProduct[]>;
	createOrder: (order: IOrder) => Promise<OrderResult>;
}
```

Интерфейс для модели данных продуктов

```typescript
export interface IProductsData {
    products:IProduct[];
    preview:string|null; //сохранение id, выбранной для отображения карточки продукта
}
```

Данные продукта, используемые в модальном окне отображения полной информации о продукте

```typescript
export type TProductInfo = Pick<IProduct, 'description'|'image'|'title'|'category'|'price'>;
```

Данные продукта, используемые в модальном окне корзины

```typescript
export type TBasketProductInfo = Pick<IProduct, 'title'|'price'>;
```

Данные пользователя, используемые в модальном окне для заполнения деталей заказа

```typescript
export type TPaymentDetails = Pick<IUser, 'payment'|'address'>;
```

Данные пользователя, используемые в модальном окне для заполнения контактов пользователя

```typescript
export type TUserContacts = Pick<IUser, 'email'|'phone'>;
```

Данные заказа, используемые в модальном окне успешной оплаты

```typescript
export type TOrderCost= Pick<IOrder, 'total'>
```

Данные заказа, используемые в модальном окне успешной оплаты

```typescript
export type TOrderCost= Pick<IOrder, 'total'>
```

export type ApiOrderResponse<Type> = {
    id: Type;       //id заказа
	total: number; // стоимость заказа
};

export type ApiGetResponse<Type> = {
    total: number; // количество товаров 
	items: Type[]; //список товаров
};


export interface OrderResult {
	id: string;
	total:number;
}

## Архитектура проекта (MVP)
Код приложения разделен на слои согласно парадигме MVP:
- Cлой представления. Отвечает за отображение данных на странице.
- Cлой данных. Отвечает за хранение и изменение данных.
- Презентер. Отвечает за связь слоев представления и данных.

<!-- Реализована единая модель данных приложения в файле `src/components/model/AppState.ts`, содержащая всю логику работы с данными и возможные действия над ними. Все изменения данных происходят через методы модели, а она в свою очередь уведомляет об изменениях через метод настроек `onChange(changes: AppStateChanges)` чтобы не зависеть от конкретного способа коммуникации между компонентами. Подключение модели к системе событий производится через обертку `src/components/model/AppStateEmitter.ts`.

Экземпляр модели передается в контроллеры, которые по факту являются обработчиками пользовательских действий и обновляют состояние модели через ее методы. Экземпляры контроллеров передаются в качестве объекта содержащего обработчики событий в верхнеуровневые отображения (экраны).

При обработке событий возникающих в AppStateEmitter производится обновление данных в верхнеуровневых отображениях. Экраны это фактически крупные сборки инкапсулирующие детали реализации интерфейса и принимающие из вне только обработчики событий и необходимые данные. Экраны внутри составлены из более мелких отображений, которые инициализируют с помощью глобальных настроек проекта и распределяют данные между вложенными отображениями через свойства и метод `render()`. -->

### Базовый код

#### Класс Api
Содержит в себе базовую логику отправки запросовю В конструктор передается базовый адрес сервера и обциональный объект с заголовками запросов.

Методы:
- `get` - выполняет GET запрос на переданный в параметрах endpoint и возвращает промис с объектом, являющимся ответом сервера.

- `post` - принимает объект с данными, которые будут переданы в JSON-формате в теле запроса, и отправляет эти данные на endpoint, переданный параметром при вызове метода. По умолчанию выполняется 'POST' запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.

#### Класс EventEmitter

Реализует паттерн «Наблюдатель» и позволяет подписываться на события и уведомлять подписчиков о наступлении события.
Класс имеет методы on , off , emit — для подписки на событие, отписки от события и уведомления подписчиков о наступлении события соответственно.

Основные методы, реализуемые классом, описаны интерфейсом 'IEvents':
- `on` - подписка на событие.
- `emit` - инициализация события.
- `trigger` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие.

Дополнительно реализованы методы onAll и offAll — для подписки на все события и сброса всех подписчиков.
Метод trigger, генерирующий заданное событие с заданными аргументами. Интересен тем, что позволяет передавать сгенерированное событие в качестве обработчика события в другие классы. Эти классы будут генерировать события, не являясь при этом напрямую зависимыми от класса EventEmitter.

### Слой данных

#### Класс ProductsData
Класс отвечает за хранение и логику работы с данными товаров, пришедших с сервера. Имплементирует интерфейс IProductsData.\
Конструктор класса принимает инстант брокера событий\
В полях класса хранятся следующие данные:
- _products: IProduct[] - массив объектов продуктов
- _preview: string | null - id карточки, выбранной для просмотра в модальной окне
- events: IEvents - экземпляр класса `EventEmitter` для инициации событий при изменении данных.

Так же класс предоставляет набор методов для взаимодействия с этими данными.
- getCard(productId: string): IProduct - возвращает карточку товара по ее id
<!-- - checkValidation(data: Record<keyof TCardInfo, string>): boolean - проверяет объект с данными карточки на валидность -->
- а так-же сеттеры и геттеры для сохранения и получения данных из полей класса

#### Класс UserData
Класс отвечает за хранение и логику работы с данными текущего пользователя. Имплементирует интерфейс IUser.\
Конструктор класса принимает инстант брокера событий\
В полях класса хранятся следующие данные:
- payment: string - Метод оплаты
- address: string - Адрес доставки
- email: string - Адрес электронной почты пользователя
- phone: string - Номер телефона пользователя
- events: IEvents - экземпляр класса `EventEmitter` для инициации событий при изменении данных.

Так же класс предоставляет набор методов для взаимодействия с этими данными.
- setUserInfo(userData: IUser): void - сохраняет данные пользователя в классе
- checkValidation(data: Record<keyof TPaymentDetails&TUserContacts, string>): boolean - проверяет объект с данными пользователя на валидность

### Классы представления
Все классы представления отвечают за отображение внутри контейнера (DOM-элемент) передаваемых в них данных.

#### Класс Modal
Реализует модальное окно. Так же предоставляет методы `open` и `close` для управления отображением модального окна. Устанавливает слушатели на клавиатуру, для закрытия модального окна по Esc, на клик в оверлей и кнопку-крестик для закрытия попапа.  
- constructor(selector: string, events: IEvents) Конструктор принимает селектор, по которому в разметке страницы будет идентифицировано модальное окно и экземпляр класса `EventEmitter` для возможности инициации событий.

Поля класса
- modal: HTMLElement - элемент модального окна
- events: IEvents - брокер событий

#### Класс ModalWithConfirm
Расширяет класс Modal. Предназначен для реализации модального окна подтверждения. При открытии модального окна сохраняет полученный в параметрах обработчик, который передается для выполнения при сабмите формы.\
Поля класса:
- submitButton: HTMLButtonElement - Кнопка подтверждения
- _form: HTMLFormElement - элемент формы
- formName: string - значение атрибута name формы
- handleSubmit: Function - функция, на выполнение которой запрашивается подтверждение

Методы:
- setValid(isValid: boolean): void - изменяет активность кнопки подтверждения
- open(handleSubmit: Function): void - расширение родительского метода, принимает обработчик, который передается при инициации события подтверждения.
- get form: HTMLElement - геттер для получения элемента формы

#### Класс ModalWithForm
Расширяет класс Modal. Предназначен для реализации модального окна с формой содержащей поля ввода. При сабмите инициирует событие передавая в него объект с данными из полей ввода формы. При изменении данных в полях ввода инициирует событие изменения данных. Предоставляет методы для отображения ошибок и управления активностью кнопки сохранения.\
Поля класса:
- submitButton: HTMLButtonElement - Кнопка подтверждения
- _form: HTMLFormElement - элемент формы
- formName: string - значение атрибута name формы
- inputs: NodeListOf<HTMLInputElement> - коллекция всех полей ввода формы
- errors: Record<string, HTMLElement> - объект хранящий все элементы для вывода ошибок под полями формы с привязкой к атрибуту name инпутов

Методы:
- setValid(isValid: boolean): void - изменяет активность кнопки подтверждения
- getInputValues(): Record<string, string> - возвращает объект с данными из полей формы, где ключ - name инпута, значение - данные введенные пользователем
- setInputValues(data: Record<string, string>): void - принимает объект с данными для заполнения полей формы
- setError(data: { field: string, value: string, validInformation: string }): void - принимает объект с данными для отображения или сокрытия текстов ошибок под полями ввода
- showInputError (field: string, errorMessage: string): void - отображает полученный текст ошибки под указанным полем ввода
- hideInputError (field: string): void - очищает текст ошибки под указанным полем ввода
- close (): void - расширяет родительский метод дополнительно при закрытии очищая поля формы и деактивируя кнопку сохранения
- get form: HTMLElement - геттер для получения элемента формы

#### Класс ModalWithImage
Расширяет класс Modal. Предназначен для реализации модального окна с изображением в большом размере. При открытии модального окна получает данные изображения, которое нужно показать.\
Поля класса:
- imageElement: HTMLImageElement - элемент разметки с изображением
- imageCaption: HTMLElement - элемент разметки для вывода названия изображения

Методы:
- open(data: { name: string, link: string }): void - расширение родительского метода, принимает данные изображения, которые используются для заполнения атрибутов элементов модального окна.
- close(): void - расширяет родительский метод, выполняя дополнительно очистку атрибутов модального окна.


#### Класс Product
Отвечает за отображение карточки товара, задавая в ней данные категорию, название, изображение и цену товара. Класс используется для отображения карточек товаров на странице сайта. В конструктор класса передается DOM элемент темплейта, что позволяет при необходимости формировать карточки разных вариантов верстки. В классе устанавливается слушатель клика на карточку, в результате срабатывания которого происходит открытие модального окна с подробной информацией о товаре.\
Поля класса содержат элементы разметки элементов карточки товара. Конструктор, кроме темплейта принимает экземпляр `EventEmitter` для инициации событий.\
Методы:
- render(cardData: Partial<ICard>, userId: string): HTMLElement - заполняет атрибуты элементов карточки данными. Метод возвращает разметку карточки с установленным слушателями. Слушатель устанавливается на всю карточку, события генерируются через экземпляр брокера событий.
- геттер id возвращает уникальный id карточки товара

#### Класс ProductsContainer
Отвечает за отображение блока с карточками товаров на главной странице. Предоставляет сеттер `container` для полного обновления содержимого. В конструктор принимает контейнер, в котором размещаются карточки.

#### Класс UserInfo
Отвечает за блок сайта с информацией о пользователе, содержит кнопки редактирования данных пользователя и создания новых карточек. Принимает в конструктор контейнер - элемент разметки блока профиля и экземпляр `EventEmitter` для инициации событий при нажатии пользователем на кнопки. Устанавливает в конструкторе слушатели на все кнопки, при срабатывании которых генерируются соответствующие события\
В полях класса содержатся ссылки на все элементы разметки блока.\
Методы:
- setUserInfo(userData: TUserPublicInfo): void - устанавливает данные в элементы разметки блока


### Слой коммуникации

#### Класс ShopApi
Принимает в конструктор экземпляр класса Api и предоставляет методы реализующие взаимодействие с бэкендом сервиса.

## Взаимодействие компонентов
Код, описывающий взаимодействие представления и данных между собой находится в файле `index.ts`, выполняющем роль презентера.\
Взаимодействие осуществляется за счет событий генерируемых с помощью брокера событий и обработчиков этих событий, описанных в `index.ts`\
В `index.ts` сначала создаются экземпляры всех необходимых классов, а затем настраивается обработка событий.

*Список всех событий, которые могут генерироваться в системе:*\
*События изменения данных (генерируются классами моделями данных)*
- `user:changed` - изменение данных пользователя
- `cards:changed` - изменение массива карточек
- `card:selected` - изменение открываемой в модальном окне картинки карточки
- `card:previewClear` - необходима очистка данных выбранной для показа в модальном окне карточки

*События, возникающие при взаимодействии пользователя с интерфейсом (генерируются классами, отвечающими за представление)*
- `userEdit:open` - открытие модального окна с формой редактирования данных пользователя
- `newCard:open` - открытие модального окна создания новой карточки
- `avatar:open` - открытие модального окна с формой редактирования аватара пользователя
- `card:select` - выбор карточки для отображения в модальном окне
- `card:delete` - выбор карточки для удаления
- `card:like` - изменение состояния лайка на карточке
- `edit-profile:input` - изменение данных в форме с данными пользователя
- `edit-avatar:input` - изменение данных в форме с аватаром пользователя
- `new-place:input` - изменение данных в форме создания новой карточки
- `edit-profile:submit` - сохранение данных пользователя в модальном окне
- `edit-avatar:submit` - сохранение аватара пользователя в модальном окне
- `new-place:submit` - событие, генерируемое при создании новой карточки в форме
- `remove-card:submit` - событие, генерируемое при нажатии "Да" в форме подтверждения
- `edit-profile:validation` - событие, сообщающее о необходимости валидации формы профиля
- `edit-avatar:validation` - событие, сообщающее о необходимости валидации формы аватара пользователя
- `new-place:validation` - событие, сообщающее о необходимости валидации формы создания новой карточки



































## Архитектура проекта (MVC)

Реализована единая модель данных приложения в файле `src/components/model/AppState.ts`, содержащая всю логику работы с данными и возможные действия над ними. Все изменения данных происходят через методы модели, а она в свою очередь уведомляет об изменениях через метод настроек `onChange(changes: AppStateChanges)` чтобы не зависеть от конкретного способа коммуникации между компонентами. Подключение модели к системе событий производится через обертку `src/components/model/AppStateEmitter.ts`.

Экземпляр модели передается в контроллеры, которые по факту являются обработчиками пользовательских действий и обновляют состояние модели через ее методы. Экземпляры контроллеров передаются в качестве объекта содержащего обработчики событий в верхнеуровневые отображения (экраны).

При обработке событий возникающих в AppStateEmitter производится обновление данных в верхнеуровневых отображениях. Экраны это фактически крупные сборки инкапсулирующие детали реализации интерфейса и принимающие из вне только обработчики событий и необходимые данные. Экраны внутри составлены из более мелких отображений, которые инициализируют с помощью глобальных настроек проекта и распределяют данные между вложенными отображениями через свойства и метод `render()`.

Общую цепочку взаимодействия можно представить следующим образом:

```typescript
const api = new Api(); // Инициализация API
const app = new ModelEmitter(api); // Инициализация модели и событий
const screen = new Screen( // Инициализация экрана
	// экран ждет объект с обработчиками событий, например { onClick: () => void }
	new Controller( // Инициализация контроллера
		/* { // Обработчики событий
            onClick: () => {
                app.model.value += 1;
            }
        }*/
		app.model // Передача модели в контроллер
	)
);

app.on('change:value', () => {
	screen.value = app.model.value;
});

// Screen.onClick -> Controller.onClick -> Model.value -> Screen.value
```

И таким образом соединяем между собой все компоненты приложения.

### API

Базовый функционал класса API будет расширен классом ShopAPI, соответсвующим интерфейсу IShopAPI. В данном классе будут сформированы два метода.

```typescript
class ShopAPI extends Api implements IShopAPI {
	getItems: () => Promise<Item[]>; // получение списка элементов
	orderItems: (order: Order) => Promise<OrderResult[]>; // отправка заказа на сервер
}
```

### Базовый код

Модели в проекте представлены классом `AppState`, который содержит в себе все данные и логику работы с ними. Модель частично реализует паттерн "Наблюдатель", и уведомляет об изменениях через метод `onChange(changes: AppStateChanges)`. Для удобства работы с данными в модели реализованы методы для изменения данных, которые в свою очередь вызывают метод `onChange()`.

Предполагается,что модель данных будет выглядеть следующим образом:

```typescript
export class AppStateModel implements AppState {
	items: Map<string, Item> = new Map<string, Item>();
	_selectedItem: string | null = null;
	basket: Map<string, BasketItem> = new Map<string, BasketItem>();

	details: Details = {
		payment: '',
		address: '',
	};
	contacts: Contacts = {
		email: '',
		phone: '',
	};

	openedModal: AppStateModals = AppStateModals.none;
	modalMessage: string | null = null;
	isError = false;

	constructor(protected api: IShopAPI, protected settings: AppStateSettings) {}

	get basketTotal(): number {} // метод для подсчета полной стоимости корзины
	get isOrderReady(): boolean {} //метод для определения полноты оформления заказа, а именно выбраны опрделенные товары, заполнены все поля данных: адрес, почта телефон, выбран способ оплаты
	get selectedItem(): Item | null {} // геттер для получения полной информации выбранного элемена
	get order(): Order {} // геттер для создания объекта, соответсвующего типу Order и содержащего всю необходимую информацию по заказу. Именно в таком виде данные уходять на сервер

	// api actions
	async loadItems(): Promise<void> {} // метод, основанный на работе api.getItems(), служит для формирования map items
	async orderItems(): Promise<OrderResult[]> {} // метод, основанный на работе api.orderItems, служит для отправки данных order на сервер, а также после успешного заказа сохраняет контактные данные в localStorage и подставляются в форму заказа в следующий раз

	// user actions
	selectItem(id: string | null): void {} // метода для выбора продукта, переданный id сохраняется в свойство _selectedItem
	removeItem(id: string): void {} // метод для удаления товара из корзины
	fillDetails(details: Partial<Details>): void {} // метод, формирующий объект details при их заполнении
	fillContacts(contacts: Partial<Contacts>): void {} // метод, формирующий объект contacts при их заполнении
	isValid(): boolean {} // метод, валидирующий введенные данные

	// UI methods
	openModal(modal: AppStateModals): void {}

	setMessage(message: string | null, isError = false): void {
		this.modalMessage = message;
		this.isError = isError;
		this.notifyChanged(AppStateChanges.modalMessage);
	}

	// helpers
	getBasketItem(): BasketItem | null {
		if (this.basket.size === 0) {
			return null;
		}
		const items = Array.from(this.basket.values());
		items.forEach((item) => {
			return {
				id: item.id,
				title: item.title,
				price: item.price,
			};
		});
	}

	formatItemDescription(item: BasketItem): BasketItemDescription {
		return {
			id: item.id,
			title: item.title,
			price: this.formatCurrency(item.price),
		};
	}

	formatCurrency(value: number): string {
		return this.settings.formatCurrency(value);
	}

	restoreState(): void {
		if (!localStorage || !this.settings.storageKey) {
			return;
		}

		try {
			const state = localStorage.getItem(this.settings.storageKey);
			if (!state) return;
			const { items, details, contacts } = JSON.parse(state) as PersistedState;
			this.details = details;
			this.contacts = contacts;
			this.basket.clear();
			for (const item of items) {
				this.basket.set(item.id, item);
			}
			this.notifyChanged(AppStateChanges.basket);
			this.notifyChanged(AppStateChanges.order);
		} catch (err) {
			console.error('Failed to restore state:', err);
		}
	}

	persistState(): void {
		const state: PersistedState = {
			details: this.details,
			contacts: this.contacts,
			items: Array.from(this.basket.values()),
		};
		if (localStorage && this.settings.storageKey) {
			localStorage.setItem(this.settings.storageKey, JSON.stringify(state));
		}
	}

	protected notifyChanged(changed: AppStateChanges): void {
		this.settings.onChange(changed);
	}

	protected validateContacts();
}
```

### Отображения

Отображения в проекте разделены на три типа:

- `common` — общие компоненты, не зависящие от доменной области проекта
- `partial` — частичные компоненты, реализующие доменную область проекта
- `screen` — верхнеуровневые компоненты, которые являются экранами приложения

Первые два типа (common и partial) независимо типизированы, не используют глобальных настроек напрямую и могут быть легко переносимы между проектами. Экраны (screen) же зависят от глобальных настроек и используют их для инициализации и передачи данных между вложенными отображениями, так как по факту это соединительный код для удобства вынесенные в отдельные файлы и оформленный как отображение.

Каждое отображение (кроме Screen) устроено следующим образом:

```typescript
class Component extends View<Тип_данных, Тип_настроек> {
	constructor(
		public element: HTMLElement,
		protected readonly settings: Settings
	) {
		super(element, settings);
		// Не переопределяем конструктор в своих отображениях!
	}

	protected init() {
		// Используем метод жизненного цикла, для инициализация компонента
		// Здесь вешаем события
	}

	set value(value: number) {
		// Устанавливаем поле данных "value" в верстке
	}

	render() {
		// Отрисовка компонента
		// Переопределяем только по необходимости
		return this.element;
	}
}
```

Если необходимо использовать в одном отображении другие, то передаем их через настройки, не создавая зависимость напрямую. Пример:

```typescript
interface ChildData {
	value: number;
}

interface ComponentData {
	content: ChildData;
}

interface ComponentSettings {
	contentView: IView<ChildData>; // Ждем отображение принимающее данные типа ChildData
}

class Component extends View<Тип_данных, Тип_настроек> {
	set content(data: ChildData) {
		this.settings.contentView.render(data);
		// или this.settings.contentView.value = data.value;
	}
}
```

Если нужно использовать переданное отображение как шаблон, то можно использовать метод `copy()` — копирующие конструктор, который создает новый экземпляр отображения с теми же настройками (но их можно переопределить через параметры метода).

### Модели

Модели в проекте представлены классом `AppState`, который содержит в себе все данные и логику работы с ними. Модель частично реализует паттерн "Наблюдатель", и уведомляет об изменениях через метод `onChange(changes: AppStateChanges)`. Для удобства работы с данными в модели реализованы методы для изменения данных, которые в свою очередь вызывают метод `onChange()`.

В целом типовая модель данных выглядит следующим образом:

```typescript
enum ModelChanges {
	// Изменения в модели
	value = 'change:value',
}

interface ModelSettings {
	// Настройки модели
	onChange(changes: ModelChanges): void;
}

class Model {
	constructor(
		protected api: Api, // API для работы с данными
		protected settings: ModelSettings // Настройки и обработчики событий
	) {
		// Инициализация модели
	}

	// Методы для изменения данных
	public changeValue(value: number) {
		// Изменение данных
		this.onChange(ModelChanges.value);
	}
}
```

### Контроллеры

Контроллеры в проекте представлены классами унаследованными от `Controller`, и являются обработчиками пользовательских действий и обновляют состояние модели через ее методы. Контроллеры принимают в себя экземпляр модели и обрабатывают события, вызывая методы модели для изменения данных.

Пример контроллера:

```typescript
class Controller {
	constructor(
		protected model: Model // Модель для работы с данными
	) {
		// Инициализация контроллера
	}

	public onClick = () => {
		// чтобы не потерять контекст
		// Обработка события
		this.model.changeValue(1);
	};
}
```

Обычно при использовании контроллеров бизнес-логику перераспределяют так, что в моделях не принимаются решения, а только изменяются данные с соблюдением их взаимозависимостей. В контроллерах же происходит обработка событий и принятие решений, а также обновление данных в моделях. Но это не строгое правило и в зависимости от проекта можно использовать разные подходы, например в этом проекте используется несколько реализаций архитектуры в разных ветках и чтобы не переносить много кода модель реализует практически всю логику, что несколько упрощает роль контроллеров.
